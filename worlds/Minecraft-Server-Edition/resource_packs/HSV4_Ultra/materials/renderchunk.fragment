// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif
#endif

varying vec4 color;
varying highp vec3 position;
varying highp vec3 worldpos;
varying highp vec2 screen;

#ifdef FOG
varying vec4 fogColor;
#endif

#include "uniformShaderConstants.h"
#include "util.h"
#include "global_function.h"

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

///// saturation function
vec3 saturation(vec3 albedo, float adjust)
 {
   vec3 intensity = vec3(dot(albedo, 
   vec3(.2125, .7154, .0721)));
       return mix(intensity, albedo, adjust); 
}

///// sampler of colors
bool red_sampler(vec3 x){
   if(lessThan(x, vec3(.85,.25,.25))==bvec3(true) && 
   greaterThan(x, vec3(.825,.1,.1))==bvec3(true)){
 return true; } else { return false;
  }
}
 bool green_sampler(vec3 x){
   if(lessThanEqual(x, vec3(0., 1., 0.))==bvec3(true) && 
   greaterThanEqual(x, vec3(0., .8, 0.))==bvec3(true)){
 return true; } else { return false;
  }
}
  bool pixel_color(vec3 x){
   if(!(lessThan(x, vec3(.5, .5, .5))==bvec3(true) || 
   greaterThan(x, vec3(.0, .0, .0))==bvec3(true))){
 return true; } else { return false;
  }
}

///// sun reflection
vec4 specular(vec4 albedo, float transition, float wave, float n){

   // calculate position
   vec3 raypos = (worldpos*7.5) / abs(worldpos.x);
   raypos.y -= transition;
   raypos.y -= .5 * (worldpos.y * .2);
#ifdef WATER_WAVE
   raypos.xz = reflect(raypos.xz, vec2(wave *.5));
#endif
   float bloomshape = clamp(length(raypos.zy / 7.5), .0, 1.);

   // result
   float shape = (1.-abs(raypos.z))-(abs(raypos.y));
   vec3 bloom = mix(mix(vec3(1.6, 1.2, .6) * 1.6, vec3(.8), n), albedo.rgb, bloomshape);
   vec3 sun = max(mix(albedo.rgb, vec3(1.8, 1.6, .8) * 1.5, step(.2, shape)), mix(albedo.rgb, vec3(1.4) * 1.5, step(.3, shape)));

#if defined SUN_REF && defined SUN_SHAPE
    return max(vec4(bloom, 1.), vec4(sun, 1.));
#else
    return vec4(bloom, 1.);
#endif
}

void main()
{
#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(0, 0, 0, 0);
	return;
#else 

     vec2 shiftclr = vec2(.019, .0);
     vec2 shiftpixel = vec2(.03125, .0);

#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0, uv0);
  vec3 clrsampler = texture2D_AA(TEXTURE_0, uv0+shiftclr).rgb;
  vec3 clrpixel = texture2D_AA(TEXTURE_0, uv0+shiftpixel).rgb;
#else
	vec4 diffuse = texture2D(TEXTURE_0, uv0);
   vec3 clrsampler = texture2D(TEXTURE_0, uv0+shiftclr).rgb;
   vec3 clrpixel = texture2D(TEXTURE_0, uv0+shiftpixel).rgb;
#endif
	
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif

#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif
	if(diffuse.a < ALPHA_THRESHOLD){
		discard; return;}
#endif
	
vec4 inColor = color;


#if defined(BLEND)
	diffuse.a *= inColor.a;
#endif

#if !defined(ALWAYS_LIT)
 if(!(red_sampler(clrsampler) && pixel_color(clrpixel))){
	diffuse *= texture2D( TEXTURE_1, uv1 );}
#endif

#ifndef SEASONS
	#if !USE_ALPHA_TEST && !defined(BLEND)
		diffuse.a = inColor.a;
	#endif
inColor.rgb = color.g * 2. > color.b + color.r? inColor.rgb : mix(inColor.rgb, sqrt(inColor.rgb), .25);

	diffuse.rgb *= inColor.rgb;
#else
	vec2 uv = inColor.xy;
	diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	diffuse.rgb *= inColor.aaa;
	diffuse.a = 1.0;
#endif
vec3 N = normalize(cross(dFdx(worldpos), dFdy(worldpos)));

#ifdef FOG
	diffuse.rgb = mix( diffuse.rgb, fogColor.rgb, fogColor.a );
#endif

	gl_FragColor = diffuse;
	
#endif // BYPASS_PIXEL_SHADER
}
